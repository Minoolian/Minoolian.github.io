---
layout: post
title: "LeetCode 133ë²ˆ: Clone Graph(JAVA)"
category: tech
tags: algorithm
image:
  path:   https://github.com/Minoolian/Minoolian.github.io/assets/44282342/3befd288-1353-46ee-9658-4b059f889f94
---

* unordered toc
{:toc .large-only}

**ë¬¸ì œì¶œì²˜** [133ë²ˆ: Clone Graph](https://leetcode.com/problems/clone-graph/description/?envType=study-plan-v2&envId=top-interview-150){:.heading.flip-title}
{:.read-more}


# â” ë¬¸ì œ
***

ë¬´ë°©í–¥ ì—°ê²° ê·¸ë˜í”„ì˜ `val=1` ì¸ Nodeê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ë¬´ë°©í–¥ ì—°ê²° ê·¸ë˜í”„ì˜ Clone(deepcopy)ì„ êµ¬ì„±í•˜ì—¬ ë³µì‚¬ëœ `val=1`ì¸ Nodeë¥¼ ë°˜í™˜í•˜ëŠ” ë¬¸ì œ.

# â© ì˜ˆì‹œ
***
![graph](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)

**Input**: adjList = [[2,4],[1,3],[2,4],[1,3]]  
**Output**: [[2,4],[1,3],[2,4],[1,3]]
**Explanation** : There are 4 nodes in the graph.  
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).  
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).  
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).  
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
 
# â• ë¬¸ì œí’€ì´
***

```java
import java.util.*;

class Solution {
    Map<Integer, Node> visited = new HashMap<>(); // ë°©ë¬¸í•œ ë…¸ë“œì˜ valê³¼ ë³µì‚¬ëœ í•´ë‹¹ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” Map

    public Node cloneGraph(Node node) {
        
        if(node == null) return null; // 1.
        return dfs(node);
    }

    public Node dfs(Node node){ // 2.
        Node newNode = new Node(node.val); // 3.
        visited.put(node.val, newNode); // 4. 

        for(Node neighbor : node.neighbors){ // 5.
            if(!visited.containsKey(neighbor.val)){ // 6.
                newNode.neighbors.add(dfs(neighbor)); // 7.
            }else{
                newNode.neighbors.add(visited.get(neighbor.val));
            }
        }

        return newNode;
    }
}
```

1. ê°„ì„ ì´ ì—†ë‹¤ë©´ ê·¸ëŒ€ë¡œ nullì„ ë°˜í™˜í•œë‹¤.
2. DFS ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê¸°ì¡´ ê·¸ë˜í”„ë¥¼ íƒìƒ‰í•œë‹¤.
3. í˜„ì¬ Nodeë¥¼ ë³µì œí•˜ë˜, NeighborëŠ” ë¹„ì–´ìˆë‹¤.
4. í˜„ì¬ Nodeì˜ ê°’ì„ ë°©ë¬¸ì²˜ë¦¬í•˜ê³ , ë³µì œëœ Nodeë¥¼ Mapì— ê°™ì´ ì‚½ì…í•œë‹¤.
5. í˜„ì¬ Nodeì˜ Neighborë¥¼ ìˆœíšŒí•œë‹¤.
6. Neighborê°€ ë°©ë¬¸í•˜ì§€ ì•Šì€ Node(val)ë¼ë©´ Neighborë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ dfsë¥¼ í˜¸ì¶œí•˜ê³  ë°˜í™˜ê°’ì„ ë³µì œëœ ë…¸ë“œì˜ Neighborì— ì¶”ê°€í•œë‹¤.
7. Neighborê°€ ë°©ë¬¸í•œ Node(val)ë¼ë©´ visitedì˜ valì„ í†µí•´ ë³µì œëœ Nodeë¥¼ Neighborì— ì¶”ê°€í•œë‹¤.

# ğŸ’¯ ê³ ì°°
***

Solution ì½”ë“œë“¤ì€ í’€ì´ëŠ” ëŒ€ë¶€ë¶„ **BFS, DFS, forë¬¸**ìœ¼ë¡œ í’€ì´ë¥¼ í–ˆë‹¤. ë‹¤ë§Œ Memoryì™€ Runtimeì˜ ì°¨ì´ëŠ” ë¶„ê¸°ì²˜ë¦¬, Mapì˜ ì‚¬ìš© ë“±ìœ¼ë¡œ ë‚˜ë‰œê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.  
**1ms, 0.2MB ì •ë„ì˜ í¬ì§€ ì•Šì€ ì°¨ì´**ì§€ë§Œ ì—¬ëŸ¬ í’€ì´ë¥¼ ë³´ë©° ìƒˆë¡œìš´ ë°©ì‹ë“¤ì„ ì ‘í•œ ê²½í—˜ì´ ë˜ì—ˆë‹¤.