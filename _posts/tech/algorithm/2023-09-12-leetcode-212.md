---
layout: post
title: "LeetCode 212ë²ˆ: Word Search II(JAVA)"
category: tech
tags: algorithm
image:
  path:   https://github.com/Minoolian/Minoolian.github.io/assets/44282342/3befd288-1353-46ee-9658-4b059f889f94
---

* unordered toc
{:toc .large-only}

**ë¬¸ì œì¶œì²˜** [212ë²ˆ: Word Search II](https://leetcode.com/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150){:.heading.flip-title}
{:.read-more}


# â” ë¬¸ì œ
***

String ë°°ì—´ `words`ì˜ ê° ë‹¨ì–´ ì¤‘ M*N char ë°°ì—´ `board`ì—ì„œ ìƒí•˜ì¢Œìš°ë¡œ ì—°ì†ëœ ë¬¸ìì—´ì— ì†í•œ ë‹¨ì–´ë¥¼ ì¶œë ¥. 

# â© ì˜ˆì‹œ
***

**Input**: nboard = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],  
words = ["oath","pea","eat","rain"]  
**Output**: ["eat","oath"]
 
# â• ë¬¸ì œí’€ì´
***

```java
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    Set<String> result = new HashSet<>();

    int[] dx = new int[]{0, 1, 0, -1};
    int[] dy = new int[]{1, 0, -1, 0};

    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();

        for (String word : words) { // 1.
            trie.insert(trie.root, word.split(""), 0);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i = 0; i < board.length; i++) { // 2.
            for (int j = 0; j < board[0].length; j++) {
                visited[i][j] = true;
                search(board, visited, i, j, trie.root);
                visited[i][j] = false;
            }
        }

        return new ArrayList<>(result);
    }

    public void search(char[][] board, boolean[][] visited, int x, int y, Node node) {
        String s = String.valueOf(board[x][y]); // í˜„ì¬ ì¸ë±ìŠ¤ì˜ board ê°’

        Node next = node.children.get(s); // 3.
        if (next == null) return;

        if (next.isEndOfWord) { // 4.
            result.add(next.word);
        }

        for (int i = 0; i < 4; i++) { // 5.
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && ny >= 0 && nx < visited.length && ny < visited[0].length && !visited[nx][ny]) {
                visited[nx][ny] = true;
                search(board, visited, nx, ny, next);
                visited[nx][ny] = false;
            }
        }
    }

    class Trie {
        Node root;

        public Trie() {
            this.root = new Node();
        }

        public void insert(Node node, String[] word, int idx) {
            if (idx == word.length) {
                node.isEndOfWord = true;
                node.word = String.join("", word);
                return;
            }

            String s = word[idx];
            Node child = node.children.get(s);

            if (child == null) {
                child = new Node();
                node.children.put(s, child);
            }

            insert(child, word, idx + 1);
        }
    }

    class Node {
        Map<String, Node> children;
        boolean isEndOfWord;

        String word;

        public Node() {
            this.children = new HashMap<>();
            this.isEndOfWord = false;
        }
    }
}
```

1. Trie ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•˜ì—¬ words ë°°ì—´ì˜ ë‹¨ì–´ë“¤ì„ íŠ¸ë¦¬ì— í¬í•¨ì‹œí‚¨ë‹¤.
2. boardì˜ ê° ë‹¨ì–´ì— ëŒ€í•´ search(DFS ì•Œê³ ë¦¬ì¦˜)ë¥¼ ìˆ˜í–‰í•œë‹¤.
3. í˜„ì¬ boardì˜ ê°’ì´ Trie íŠ¸ë¦¬ì˜ ìì‹ì— ì†í•˜ë©´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì§„í–‰í•œë‹¤.
4. ë§Œì•½ ë°©ê¸ˆ ì°¾ì€ ìì‹ì˜ ë…¸ë“œê°€ ë‹¨ì–´ì˜ ëì´ë¼ë©´ í•´ë‹¹ ë‹¨ì–´ê°€ ì—°ì†ë˜ì–´ í¬í•¨ëœ ê²ƒì´ë¯€ë¡œ ê²°ê³¼ê°’ì— ì¶”ê°€í•œë‹¤.
5. boardì˜ ìƒí•˜ì¢Œìš°ë¥¼ íƒìƒ‰í•˜ë©° ê°€ëŠ¥í•œ ì¸ë±ìŠ¤ì— ëŒ€í•´ ë‹¤ì‹œ searchë¥¼ ì‹œí–‰í•œë‹¤.

# ğŸ’¯ ê³ ì°°
***

**DFS**ì™€ **Trie** ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•˜ì˜€ë‹¤.  
í•˜ì§€ë§Œ ë‚´ê°€ í‘¼ ë°©ì‹ì˜ ***ëŸ°íƒ€ì„ì‹œê°„ê³¼ ê³µê°„ë³µì¡ë„ê°€ ìƒë‹¹íˆ ë¹„íš¨ìœ¨ì ***ì´ë¼ëŠ” ê²°ê³¼ê°€ ë‚˜ì™”ë‹¤.

```java
public List<String> findWords(char[][] board, String[] words) {
    List<String> res = new ArrayList<>();
    TrieNode root = buildTrie(words);
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            dfs (board, i, j, root, res);
        }
    }
    return res;
}

public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
    char c = board[i][j];
    if (c == '#' || p.next[c - 'a'] == null) return;
    p = p.next[c - 'a'];
    if (p.word != null) {   // found one
        res.add(p.word);
        p.word = null;     // de-duplicate
    }

    board[i][j] = '#';
    if (i > 0) dfs(board, i - 1, j ,p, res); 
    if (j > 0) dfs(board, i, j - 1, p, res);
    if (i < board.length - 1) dfs(board, i + 1, j, p, res); 
    if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); 
    board[i][j] = c;
}

public TrieNode buildTrie(String[] words) {
    TrieNode root = new TrieNode();
    for (String w : words) {
        TrieNode p = root;
        for (char c : w.toCharArray()) {
            int i = c - 'a';
            if (p.next[i] == null) p.next[i] = new TrieNode();
            p = p.next[i];
       }
       p.word = w;
    }
    return root;
}

class TrieNode {
    TrieNode[] next = new TrieNode[26];
    String word;
}
```

í•´ë‹¹ ì†”ë£¨ì…˜ì€ ë‚´ê°€ í’€ì´í•œ ì•Œê³ ë¦¬ì¦˜ì˜ ë°©ì‹ë“¤ê³¼ëŠ” ì°¨ì´ê°€ ì—†ì§€ë§Œ, ì½”ë“œ ìµœì í™”ë¥¼ ìœ„í•œ ì—¬ëŸ¬ ê³ ë¯¼ì„ í•œ ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.

1. DFSì‹œ ë¶ˆí•„ìš”í•œ root(Trie ì•Œê³ ë¦¬ì¦˜ì— ìˆëŠ”)ë…¸ë“œ í˜¸ì¶œì„ ì œê±°.
2. `chatAt()` ë³´ë‹¤ `toChatArray()` ì‚¬ìš©.
3. String ì—°ì‚°ì€ `StringBuilder` í´ë˜ìŠ¤ ì‚¬ìš©.
4. ë¬¸ìì˜ ëì„ ì•Œë¦¬ëŠ” boolean ëŒ€ì‹  ì „ì²´ ë¬¸ìë¥¼ ì €ì¥í•˜ì—¬ `StringBuilder`ë¥¼ ì œê±°.
5. ì¶”ê°€ì ì¸ ê³µê°„ `boolean[][] visited` ëŒ€ì‹  boardì˜ ë¬¸ìë¥¼ "#"ìœ¼ë¡œ ì ì‹œ ë³€ê²½í•˜ì—¬ ë°©ë¬¸ì„ ì²´í¬.
6. ì•ŒíŒŒë²³ 26ê°œì˜ char ë°°ì—´ì„ ì´ìš©í•˜ì—¬ `HashSet`ì„ ì œê±°. (ì•ŒíŒŒë²³ì—ì„œ 'a'ì½”ë“œê°’ì„ ëº€ ASCIIë¥¼ ì´ìš©)

í•´ë‹¹ ë¬¸ì œë¥¼ í’€ì´í•œ ì €ìê°€ ì²˜ìŒ ì“°ë ˆê¸° ì½”ë“œì—ì„œ ìµœì í™”ë¥¼ í†µí•´ **íš¨ìœ¨ì„±ì´ ì¢‹ì€ ì½”ë“œë¡œ ë³€ê²½**í•˜ëŠ” ê³¼ì •ì„ ì´ë ‡ê²Œ ê¸°ìˆ í•˜ì˜€ë‹¤.  
í•˜ë‚˜ì˜ ë¬¸ì œì—ë„ ë” ë‚˜ì€ ì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ìœ„í•œ ë°©ë²•ì´ ì°¸ì‹ í•˜ê²Œ ë§ì€ ê²ƒ ê°™ë‹¤.